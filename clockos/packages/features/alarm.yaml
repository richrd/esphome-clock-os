# Persist alarm state and time in globals
globals:
  - id: global_feature_alarm_enabled
    type: bool
    initial_value: 'false'

  - id: global_feature_alarm_hour
    type: int
    initial_value: '9'
    restore_value: yes

  - id: global_feature_alarm_minute
    type: int
    initial_value: '30'
    restore_value: yes


# Set initial values for alarm time number components on boot
esphome:
  on_boot:
    then:
      # Initialize wake up time number components from persisted globals
      - number.set:
          id: feature_alarm_time_hour
          value: !lambda "return id(global_feature_alarm_hour);"
      - number.set:
          id: feature_alarm_time_minute
          value: !lambda "return id(global_feature_alarm_minute);"


# Handle triggering the alarm at the set time
time:
  - id: !extend clockos_time_sntp
    on_time:
      - seconds: 0
        then:
          - script.execute: script_feature_alarm_check
  - id: !extend clockos_time_ha
    on_time:
      - seconds: 0
        then:
          - script.execute: script_feature_alarm_check

display:
  - id: !extend clockos_display
    pages:
      - id: page_app_alarm
        lambda: !include "alarm.cpp"


# Provide switches for alarm features
switch:
  # If the alarm is enabled
  - platform: template
    name: "Alarm enabled"
    id: switch_feature_alarm_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(global_feature_alarm_enabled);
    turn_on_action:
      - lambda: 'id(global_feature_alarm_enabled) = true;'
    turn_off_action:
      - lambda: 'id(global_feature_alarm_enabled) = false;'
  # If the alarm is currently playing
  - platform: template
    name: "Alarm active"
    id: switch_feature_alarm_active
    restore_mode: ALWAYS_OFF
    optimistic: true
    turn_on_action:
      - script.execute: script_feature_alarm_sound
    turn_off_action:
      - script.stop: script_feature_alarm_sound
      - rtttl.stop


# Add alarm menu items
graphical_display_menu:
  id: main_menu
  items:
    - id: !extend menu_submenu_clock
      items:
        - type: menu
          text: ' Alarm ⏵ '
          id: menu_submenu_alarm
          items:
            - type: back
              text: ' ⏴ Back '
            - type: command
              text: !lambda |-
                return std::string(" Alarm [") + (id(global_feature_alarm_enabled) ? "ON" : "OFF") + "]";
              on_value:
                then:
                  - if:
                      condition:
                        lambda: 'return id(global_feature_alarm_enabled);'
                      then:
                        - switch.turn_off: switch_feature_alarm_enabled
                      else:
                        - switch.turn_on: switch_feature_alarm_enabled
            - type: number
              text: ' Hour '
              number: feature_alarm_time_hour
            - type: number
              text: ' Minute '
              number: feature_alarm_time_minute


# Handle alarm sound
script:
  - id: script_feature_alarm_check
    then:
      - if:
          # Condition 1: Check if the alarm switch is on
          condition:
            switch.is_on: switch_feature_alarm_enabled
          then:
            - if:
                # Condition 2: Check if the current time matches the dynamic alarm time
                condition:
                  lambda: |-
                    // Get the desired alarm hour and minute from global variables
                    int alarm_hour = id(global_feature_alarm_hour);
                    int alarm_minute = id(global_feature_alarm_minute);

                    int current_hour = -1;
                    int current_minute = -1;

                    auto sntp = id(clockos_time_sntp).now();
                    if (sntp.is_valid()) {
                        // return sntp.timestamp;
                        current_hour = id(clockos_time_sntp).now().hour;
                        current_minute = id(clockos_time_sntp).now().minute;
                    }

                    auto ha = id(clockos_time_ha).now();
                    if (ha.is_valid()) {
                        current_hour = id(clockos_time_ha).now().hour;
                        current_minute = id(clockos_time_ha).now().minute;
                    }

                    // Return true if current time matches the alarm time
                    return (current_hour == alarm_hour) && (current_minute == alarm_minute);
                then:
                  - script.execute: script_update_last_activity
                  - display_menu.hide: main_menu
                  - display.page.show: page_app_alarm
                  - switch.turn_on: switch_feature_alarm_active
  - id: script_feature_alarm_sound
    then:
      # Play the most annoying alarm sound possible (beep beep beep beep x4, wait ... repeat)
      - rtttl.play: 'Untitled:d=32,o=6,b=100:e,p,e,p,e,p,e,p,p,p,p,p,e,p,e,p,e,p,e,p,p,p,p,p,e,p,e,p,e,p,e,p,p,p,p,p,e,p,e,p,e,p,e'
      - delay: 5s
      - if:
          condition:
            switch.is_on: switch_feature_alarm_enabled
          then:
            - script.execute: script_feature_alarm_sound_repeat
  - id: script_feature_alarm_sound_repeat
    then:
      - delay: 1s
      - if:
          condition:
            switch.is_on: switch_feature_alarm_enabled
          then:
            - script.execute: script_feature_alarm_sound



# Wake up time hours/minutes
number:
  - platform: template
    id: feature_alarm_time_hour
    name: "Wake up hour"
    min_value: 0
    max_value: 23
    step: 1
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(global_feature_alarm_hour) = (int)x;
  - platform: template
    id: feature_alarm_time_minute
    name: "Wake up minute"
    min_value: 0
    max_value: 59
    step: 1
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(global_feature_alarm_minute) = (int)x;


# Silence alarm when knob/select button is pressed
binary_sensor:
  - platform: gpio
    id: !extend clockos_select_button
    on_press:
      then:
      - if:
          condition:
            switch.is_on: switch_feature_alarm_active
          then:
            - switch.turn_off: switch_feature_alarm_active
